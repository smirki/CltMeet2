Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\.gitignore
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2
Contents:
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

images/
.env
.json

# Expo
.expo/
dist/
web-build/

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\App.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2
Contents:
// App.js

import React from 'react';
import { ActivityIndicator, View } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { MatchesProvider } from './MatchesContext';
import { AuthProvider, AuthContext } from './context/AuthContext';
import LoginScreen from './screens/LoginScreen';
import SignUpScreen from './screens/SignUpScreen';
import ProfileScreen from './screens/ProfileScreen'; // Import ProfileScreen
import MainTabs from './screens/MainTabs'; // Assuming you have MainTabs for authenticated users

const Stack = createNativeStackNavigator();

// Create a separate component to handle navigation based on auth state
const AppNavigator = () => {
  const { userToken, loading } = React.useContext(AuthContext);

  if (loading) {
    // Show a loading indicator while checking for token
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#FF3B30" />
      </View>
    );
  }

  return (
    <Stack.Navigator initialRouteName={userToken ? "Main" : "Login"}>
      {userToken ? (
        <>
          <Stack.Screen
            name="Main"
            component={MainTabs}
            options={{ headerShown: false }}
          />
          <Stack.Screen
            name="Profile"
            component={ProfileScreen}
            options={{ title: 'Profile' }}
          />
        </>
      ) : (
        <>
          <Stack.Screen
            name="Login"
            component={LoginScreen}
            options={{ headerShown: false }}
          />
          <Stack.Screen
            name="SignUp"
            component={SignUpScreen}
            options={{ title: 'Sign Up' }}
          />
        </>
      )}
    </Stack.Navigator>
  );
};

export default function App() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <NavigationContainer>
        <AuthProvider>
          <MatchesProvider>
            <AppNavigator />
          </MatchesProvider>
        </AuthProvider>
      </NavigationContainer>
    </GestureHandlerRootView>
  );
}

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\app.json
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2
Contents:
{
  "expo": {
    "name": "CltMeet2",
    "slug": "CltMeet2",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-secure-store"
    ]
  }
}


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\firebaseConfig.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2
Contents:
// firebaseConfig.js
import { initializeApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';
import { getAuth } from 'firebase/auth'; // Import Firebase Auth

const firebaseConfig = {
  apiKey: 'AIzaSyDvp-58BF6W92fTQ9fYOBpdKRhCY4qO-AQ',
  authDomain: 'cltmeet-6bbce.firebaseapp.com',
  projectId: 'cltmeet-6bbce',
  storageBucket: 'cltmeet-6bbce.appspot.com',
  messagingSenderId: '302424451390',
  appId: '1:302424451390:web:8f0ed794f55f0de0ed646f',
  measurementId: 'G-BJC9D4LFRE',
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app); 

export { db, auth };

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\MatchesContext.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2
Contents:
// MatchesContext.js
import React, { createContext, useState } from 'react';

export const MatchesContext = createContext();

export const MatchesProvider = ({ children }) => {
  const [matches, setMatches] = useState([]);
  const [outgoingMatches, setOutgoingMatches] = useState([]);

  return (
    <MatchesContext.Provider
      value={{ matches, setMatches, outgoingMatches, setOutgoingMatches }}
    >
      {children}
    </MatchesContext.Provider>
  );
};

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\api\axiosInstance.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\api
Contents:
// api/axiosInstance.js

import axios from 'axios';
import { Alert } from 'react-native';
import { AuthContext } from '../context/AuthContext';
import React from 'react';

// Create Axios instance
const axiosInstance = axios.create({
  baseURL: 'http://192.168.1.143:3000', // Ensure this matches SERVER_BASE_URL in .env
  headers: {
    'Content-Type': 'application/json',
  },
});

// Response interceptor to handle 401 errors
axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      Alert.alert(
        'Session Expired',
        'Your session has expired. Please log in again.',
        [
          {
            text: 'OK',
            onPress: () => {
              // You can implement a global logout mechanism here if needed
            },
          },
        ],
        { cancelable: false }
      );
    }
    return Promise.reject(error);
  }
);

export default axiosInstance;

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\.env
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend
Contents:
PORT=3000
JWT_SECRET=your_secure_jwt_secret_key
FIREBASE_API_KEY=AIzaSyDvp-58BF6W92fTQ9fYOBpdKRhCY4qO-AQ  # Replace with your actual Firebase API Key
SERVICE_ACCOUNT_PATH=./cltmeet-6bbce-firebase-adminsdk-l2mh4-004310ce36.json  # Update to the actual path of your Firebase service account
SERVER_BASE_URL=http://192.168.1.143:3000

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\admin.html
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend
Contents:
<!DOCTYPE html>
<html>
<head>
    <title>Admin Interface</title>
    <script>// admin.js
        async function addEvent() {
            const title = document.getElementById('eventTitle').value;
            const description = document.getElementById('eventDescription').value;
            const response = await fetch('/events', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + localStorage.getItem('adminToken') // Use stored admin token
                },
                body: JSON.stringify({ title, description })
            });
            const result = await response.json();
            alert(result.message || result.error);
        }
        
        async function deleteEvent() {
            const eventId = document.getElementById('eventId').value;
            const response = await fetch(`/events/${eventId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem('adminToken')
                }
            });
            const result = await response.json();
            alert(result.message || result.error);
        }
        
        async function makeAdmin() {
            const email = document.getElementById('userEmail').value;
            const response = await fetch('/makeAdmin', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + localStorage.getItem('adminToken')
                },
                body: JSON.stringify({ email })
            });
            const result = await response.json();
            alert(result.message || result.error);
        }
        
        async function deleteUser() {
            const email = document.getElementById('userEmail').value;
            const response = await fetch('/deleteUser', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + localStorage.getItem('adminToken')
                },
                body: JSON.stringify({ email })
            });
            const result = await response.json();
            alert(result.message || result.error);
        }
        
        // Implement a simple login mechanism for admin
        async function adminLogin() {
            const email = prompt('Enter admin email:');
            const password = prompt('Enter admin password:');
            const response = await fetch('/adminLogin', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password })
            });
            const result = await response.json();
            if (result.token) {
                localStorage.setItem('adminToken', result.token);
                alert('Admin login successful');
            } else {
                alert(result.error || 'Login failed');
            }
        }
        
        // Automatically prompt for admin login on page load
        window.onload = () => {
            if (!localStorage.getItem('adminToken')) {
                adminLogin();
            }
        };
        </script>
</head>
<body>
    <h1>Admin Interface</h1>
    <h2>Add Event</h2>
    <input type="text" id="eventTitle" placeholder="Event Title"><br>
    <textarea id="eventDescription" placeholder="Event Description"></textarea><br>
    <button onclick="addEvent()">Add Event</button>

    <h2>Delete Event</h2>
    <input type="text" id="eventId" placeholder="Event ID"><br>
    <button onclick="deleteEvent()">Delete Event</button>

    <h2>Manage Users</h2>
    <input type="text" id="userEmail" placeholder="User Email"><br>
    <button onclick="makeAdmin()">Make Admin</button>
    <button onclick="deleteUser()">Delete User</button>
</body>
</html>


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\admin.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend
Contents:
// admin.js
async function addEvent() {
    const title = document.getElementById('eventTitle').value;
    const description = document.getElementById('eventDescription').value;
    const response = await fetch('/events', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + localStorage.getItem('adminToken') // Use stored admin token
        },
        body: JSON.stringify({ title, description })
    });
    const result = await response.json();
    alert(result.message || result.error);
}

async function deleteEvent() {
    const eventId = document.getElementById('eventId').value;
    const response = await fetch(`/events/${eventId}`, {
        method: 'DELETE',
        headers: {
            'Authorization': 'Bearer ' + localStorage.getItem('adminToken')
        }
    });
    const result = await response.json();
    alert(result.message || result.error);
}

async function makeAdmin() {
    const email = document.getElementById('userEmail').value;
    const response = await fetch('/makeAdmin', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + localStorage.getItem('adminToken')
        },
        body: JSON.stringify({ email })
    });
    const result = await response.json();
    alert(result.message || result.error);
}

async function deleteUser() {
    const email = document.getElementById('userEmail').value;
    const response = await fetch('/deleteUser', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + localStorage.getItem('adminToken')
        },
        body: JSON.stringify({ email })
    });
    const result = await response.json();
    alert(result.message || result.error);
}

// Implement a simple login mechanism for admin
async function adminLogin() {
    const email = prompt('Enter admin email:');
    const password = prompt('Enter admin password:');
    const response = await fetch('/adminLogin', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
    });
    const result = await response.json();
    if (result.token) {
        localStorage.setItem('adminToken', result.token);
        alert('Admin login successful');
    } else {
        alert(result.error || 'Login failed');
    }
}

// Automatically prompt for admin login on page load
window.onload = () => {
    if (!localStorage.getItem('adminToken')) {
        adminLogin();
    }
};


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\cltmeet-6bbce-firebase-adminsdk-l2mh4-004310ce36.json
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend
Contents:
{
  "type": "service_account",
  "project_id": "cltmeet-6bbce",
  "private_key_id": "004310ce363d8cabe89106447a4a5bffc2fc01d4",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDr96PArauEFBYY\na/904NuTNybGUDF04PcKymXkZpellOpasCSNFo7wAWfj3ZFurrItXlXXLFnOG5W2\nmgXY0E25Z75lkZPxtvmsXKsv5DGOqAUqWFd1l5OlwmSl2k+rRJ5tNwORpCOK0/j4\nJAGotHj0ISWJrQ63EqOOZp5dBnCmV2KiAlnP3agB9ILfim/qkV93xj+Qk4EqJ1nk\nfgihKkqJlKxN69vA7ZglCzHHS1i69+LNVECILzJsiKBFmFaQelTGD8J69GK0NexH\nm3WOwzlA5049MOfJEGIb5gjPNKqZF+zNhXogei/x4dp1dPYZV51/XaW7lIECoV6+\nlzJGFqcXAgMBAAECggEABD07NxTMOTghELqWcfXnnwAQIB/ZvkYh5XqKbTgRqmyV\nLHwCSc8q8Jp/xE51JU/BeVN30kb7XXksWHmbzZFm7TSvBZj2109EvnGLkA37fPx3\nSWLADZVLNPLn/4L5JvW5iG0MQfwvoJyHhNmGdq0aAmtxpT7VARVCfz6pwrh02bsw\nwtCSifAN6XjR4EObErsT0e8MgccjN3+pZ7HaWcHhVaE6VfQ4XDqhixGOG2K0ngSI\njLdb702PqCC4ABokHq6qw8HqrpZwD047L1kEAn59mmaAXZqk5BvSJ5TaObHOVpVJ\n2hl2pJe9q5TWAmk4XwWLyoghHxlRczAabSjePjIMSQKBgQD8FvKdGhwstlTleL2M\nTjJDwIXCKzcDPQ3PHdMHVDZ5u6bbfAS9ZAZT/2j+O8+/n3TVQ84tzSKeTl7KHepN\ne9cIQaaB8lgKuF9SpPlJGubEHWSzLMoe1YWbTrNR83b4SV4u0mi4Wy95GtGzERHH\n++1I7SKBV0NPaFJP+B0Lo4ddtQKBgQDvoKuHHGD8JijHsHeSeh6BI98+UPgMyRLt\nGhhnoUlURVJZYRm7inZgHbZSfB3yTecShnfsPGK7Urs3/y+g2E+IKrj23rKxCqdP\nj9ltV+5zw764MpvQQLhz1MaO4H85cDQ80y5nePZbC30aioB/eZflqgKvb7mI68b3\nmRAkn3PRGwKBgF+xnluAw909QbDySpHuRSpu9Nema/WwwYM0AR2xHBTN5SNAStRS\nGgzc0dBgiBZnw4QJf0TnsBKEEXuMK5tKPXCG61w80KsRHi5TLcZQjfU4azeQ8xEN\nYPB5yZx8XVcXEseXW+VPyA+i3KOrASL3QTYDvqt2oriME2MD/pKiewpZAoGBAIFo\nAzmz2axR7zPn2KsBx/d1p9m/YDWHYPEqZoOQVklsJkyeY4cj/0lowk1JOeLgrykR\n9TFeavM+elyDMvVp24ltiPXIzjdNyYzt4j1qfxuFWjmfGwYb7YCgJ5qBIjOipJM0\neJroeCIy0hzDLyGoSJ9+cHTNoSSQL6MGxfEBK0qBAoGAaOSsmf/lYC3X5+l8gd3A\nkrlJp+ZBgb+gTNMf9pqYMvm+Ag6/FFi+OsTPPNAv2LgVJiywj1AnhMzO0YUx/K7K\nJ7Yf2hZCbC7HcBpKeb3QTisnJmLanNBaw394C1Hv+77pCZ6Ayve7rL/V0ZM/2bDB\nOAOofTzLyhxyFJ746BLOdug=\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-l2mh4@cltmeet-6bbce.iam.gserviceaccount.com",
  "client_id": "105827324448674268196",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-l2mh4%40cltmeet-6bbce.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\server.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend
Contents:
// server.js

const express = require('express');
const admin = require('firebase-admin');
const jwt = require('jsonwebtoken');
const bodyParser = require('body-parser');
const cors = require('cors');
const axios = require('axios');
const path = require('path');
require('dotenv').config(); // Load environment variables
const multer = require('multer');
const sharp = require('sharp');
const fs = require('fs');

// Initialize Firebase Admin SDK with dynamic service account path
const serviceAccountPath = process.env.SERVICE_ACCOUNT_PATH || './path/to/serviceAccountKey.json';
const serviceAccount = require(serviceAccountPath);

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

const db = admin.firestore();

// Define storage for Multer
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

// Ensure images directory exists
const imagesDir = path.join(__dirname, 'images');
if (!fs.existsSync(imagesDir)) {
  fs.mkdirSync(imagesDir);
}


const app = express();
app.use(bodyParser.json());
app.use(cors()); // Enable CORS

const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret_key'; // Store this securely
const FIREBASE_API_KEY = process.env.FIREBASE_API_KEY || 'your_firebase_api_key'; // Replace with your Firebase project's web API key

// Middleware to verify JWT token
function verifyToken(req, res, next) {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      console.warn('No Authorization header provided');
      return res.status(401).send('Unauthorized: No token provided');
    }
    const token = authHeader.split(' ')[1];
    if (!token) {
      console.warn('Authorization header malformed');
      return res.status(401).send('Unauthorized: No token provided');
    }
    
    console.log('Received JWT Token:', token); // Log the token
    
    jwt.verify(token, JWT_SECRET, (err, decoded) => {
      if (err) {
        console.error('JWT verification failed:', err.message);
        return res.status(401).send('Unauthorized: Invalid token');
      }
      req.uid = decoded.uid;
      next();
    });
  }
  

// Middleware to check if user is admin
function verifyAdmin(req, res, next) {
  const uid = req.uid;
  admin
    .auth()
    .getUser(uid)
    .then((userRecord) => {
      if (userRecord.customClaims && userRecord.customClaims.admin === true) {
        next();
      } else {
        return res.status(403).send('Forbidden: Admins only');
      }
    })
    .catch((error) => {
      console.error('Error fetching user data:', error);
      return res.status(500).send('Internal Server Error');
    });
}

// Upload Profile Picture
app.post('/uploadProfilePicture', verifyToken, upload.single('avatar'), async (req, res) => {
    const uid = req.uid;
    const file = req.file;
  
    if (!file) {
      return res.status(400).send({ error: 'No file uploaded' });
    }
  
    try {
      // Compress and save the image
      const filename = `${uid}_${Date.now()}.jpg`;
      const filepath = path.join(imagesDir, filename);
  
      await sharp(file.buffer)
        .resize(150, 150) // Resize to 150x150 pixels
        .jpeg({ quality: 80 }) // Compress the image
        .toFile(filepath);
  
        const imageUrl = `http://192.168.1.143:3000/images/${filename}`;
  
      // Update user's profile with new image URL
      await db.collection('users').doc(uid).update({
        imageUrl: imageUrl,
      });
  
      res.status(200).send({ message: 'Profile picture uploaded', imageUrl: imageUrl });
    } catch (error) {
      console.error('Error uploading profile picture:', error);
      res.status(500).send({ error: 'Error uploading profile picture' });
    }
  });
  
  

  app.post('/refresh-token', verifyToken, async (req, res) => {
    const { token } = req.body;

    try {
      // Verify the existing token
      const decoded = jwt.verify(token, JWT_SECRET);
      const uid = decoded.uid;

      // Optionally, verify if the user still exists or has necessary permissions

      // Generate a new token
      const newToken = jwt.sign({ uid }, JWT_SECRET, {
        expiresIn: '7d',
      });

      res.status(200).send({ token: newToken });
    } catch (error) {
      console.error('Error refreshing token:', error);
      res.status(401).send({ error: 'Invalid token' });
    }
});

// Admin Login
app.post('/adminLogin', async (req, res) => {
  const { email, password } = req.body;

  try {
    // Authenticate admin user using Firebase Authentication REST API
    const apiKey = process.env.FIREBASE_API_KEY || 'YOUR_FIREBASE_API_KEY';

    const response = await axios.post(
      `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${apiKey}`,
      {
        email,
        password,
        returnSecureToken: true,
      }
    );

    const { localId } = response.data;

    // Check if user is admin
    const userRecord = await admin.auth().getUser(localId);
    if (userRecord.customClaims && userRecord.customClaims.admin === true) {
      // Generate JWT Token
      const token = jwt.sign({ uid: localId }, JWT_SECRET, {
        expiresIn: '7d',
      });
      res.status(200).send({ token });
    } else {
      res.status(403).send({ error: 'Unauthorized: Not an admin' });
    }
  } catch (error) {
    res.status(400).send({ error: error.response ? error.response.data.error.message : error.message });
  }
});

// Make User Admin
app.post('/makeAdmin', verifyToken, verifyAdmin, async (req, res) => {
  const { email } = req.body;

  try {
    const user = await admin.auth().getUserByEmail(email);
    await admin.auth().setCustomUserClaims(user.uid, { admin: true });
    res.status(200).send({ message: `${email} has been made an admin.` });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Delete User
app.delete('/deleteUser', verifyToken, verifyAdmin, async (req, res) => {
  const { email } = req.body;

  try {
    const user = await admin.auth().getUserByEmail(email);
    await admin.auth().deleteUser(user.uid);
    // Optionally delete user data from Firestore
    await db.collection('users').doc(user.uid).delete();
    res.status(200).send({ message: `${email} has been deleted.` });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Sign Up
app.post('/signup', async (req, res) => {
  const { email, password, age, bio } = req.body;

  try {
    const userRecord = await admin.auth().createUser({
      email,
      password,
    });

    // Create user profile in Firestore
    await db.collection('users').doc(userRecord.uid).set({
      uid: userRecord.uid,
      email,
      name: email.split('@')[0], // Default name from email
      age: age || null,
      bio: bio || '',
      seenUsers: [],
      registeredEvents: {},
      imageUrl: 'https://via.placeholder.com/150', // Default avatar
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    res.status(200).send({ message: 'User created successfully' });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

//Events
app.post('/registerForEvent', verifyToken, async (req, res) => {
    const uid = req.uid;
    const { eventId } = req.body;
  
    try {
      // Update user's registeredEvents
      await db.collection('users').doc(uid).update({
        [`registeredEvents.${eventId}`]: true,
      });
  
      // Increment event's registeredCount
      await db.collection('events').doc(eventId).update({
        registeredCount: admin.firestore.FieldValue.increment(1),
      });
  
      res.status(200).send({ message: 'Registered for event' });
    } catch (error) {
      res.status(400).send({ error: error.message });
    }
  });

  app.post('/unregisterForEvent', verifyToken, async (req, res) => {
    const uid = req.uid;
    const { eventId } = req.body;
  
    try {
      // Remove event from user's registeredEvents
      await db.collection('users').doc(uid).update({
        [`registeredEvents.${eventId}`]: admin.firestore.FieldValue.delete(),
      });
  
      // Decrement event's registeredCount
      await db.collection('events').doc(eventId).update({
        registeredCount: admin.firestore.FieldValue.increment(-1),
      });
  
      res.status(200).send({ message: 'Unregistered from event' });
    } catch (error) {
      res.status(400).send({ error: error.message });
    }
  });
  

// Login
app.post('/login', async (req, res) => {
  const { email, password } = req.body;

  try {
    // Use Firebase Authentication REST API to verify password
    const response = await axios.post(
      `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${FIREBASE_API_KEY}`,
      {
        email,
        password,
        returnSecureToken: true,
      }
    );

    const { localId } = response.data;

    // Generate JWT Token
    const token = jwt.sign({ uid: localId }, JWT_SECRET, {
      expiresIn: '7d',
    });
    console.log('worked');

    res.status(200).send({ token });
  } catch (error) {
    res.status(400).send({ error: error.response ? error.response.data.error.message : error.message });
  }
});

// Get Swipe Profiles
app.get('/profiles', verifyToken, async (req, res) => {
    const uid = req.uid;
    const pageSize = parseInt(req.query.pageSize) || 10;
    const lastVisible = req.query.lastVisible || null;
  
    try {
      const userDoc = await db.collection('users').doc(uid).get();
      if (!userDoc.exists) {
        return res.status(404).send({ error: 'User not found' });
      }
      const userData = userDoc.data();
      const seenUsers = userData.seenUsers || [];
  
      // Combine current UID with seenUsers
      const excludedUserIds = [uid, ...seenUsers.slice(0, 9)]; // Max 10 elements
  
      let query = db.collection('users').orderBy('uid').limit(pageSize);
  
      // Exclude current user and seen users
      query = query.where('uid', 'not-in', excludedUserIds);
  
      if (lastVisible) {
        const lastDoc = await db.collection('users').doc(lastVisible).get();
        query = query.startAfter(lastDoc);
      }
  
      const snapshot = await query.get();
  
      const profiles = [];
      snapshot.forEach((doc) => {
        profiles.push(doc.data());
      });
  
      const lastDoc = snapshot.docs[snapshot.docs.length - 1];
  
      res.status(200).send({
        profiles,
        lastVisible: lastDoc ? lastDoc.id : null,
      });
    } catch (error) {
      console.error('Error fetching profiles:', error);
      res.status(400).send({ error: error.message });
    }
  });
  

// Update User Profile
app.post('/updateProfile', verifyToken, async (req, res) => {
  const uid = req.uid;
  const { name, age, bio, registeredEvents } = req.body;

  try {
    const updateData = {};
    if (name !== undefined) updateData.name = name;
    if (age !== undefined) updateData.age = age;
    if (bio !== undefined) updateData.bio = bio;
    if (registeredEvents !== undefined) updateData.registeredEvents = registeredEvents;

    await db.collection('users').doc(uid).update(updateData);
    res.status(200).send({ message: 'Profile updated successfully' });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Get User Profile
app.get('/getUserProfile', verifyToken, async (req, res) => {
  const uid = req.uid;

  try {
    const userDoc = await db.collection('users').doc(uid).get();
    if (!userDoc.exists) {
      return res.status(404).send({ error: 'User not found' });
    }
    res.status(200).send(userDoc.data());
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Mark User as Seen and Handle Match Requests
app.post('/markSeen', verifyToken, async (req, res) => {
  const uid = req.uid;
  const { seenUserId, action } = req.body; // action can be 'pass', 'friend', 'romantic'

  try {
    // Update seenUsers
    await db.collection('users').doc(uid).update({
      seenUsers: admin.firestore.FieldValue.arrayUnion(seenUserId),
    });

    if (action === 'friend' || action === 'romantic') {
      // Create or update match request
      const matchRequestRef = db.collection('matchRequests').doc(`${uid}_${seenUserId}`);
      await matchRequestRef.set({
        from: uid,
        to: seenUserId,
        type: action,
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
      });

      // Check if there's a reciprocal match request
      const reciprocalMatchRequestRef = db.collection('matchRequests').doc(`${seenUserId}_${uid}`);
      const reciprocalMatchRequestDoc = await reciprocalMatchRequestRef.get();

      if (reciprocalMatchRequestDoc.exists) {
        // Create a match
        const matchRef = db.collection('matches').doc();
        await matchRef.set({
          users: [uid, seenUserId],
          type: action, // You might want to handle different types
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        // Delete match requests
        await matchRequestRef.delete();
        await reciprocalMatchRequestRef.delete();

        // Create chat
        const chatRef = db.collection('chats').doc();
        await chatRef.set({
          users: [uid, seenUserId],
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        return res.status(200).send({ message: 'Matched', chatId: chatRef.id });
      }
    }

    res.status(200).send({ message: 'User marked as seen' });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Get Matches
app.get('/matches', verifyToken, async (req, res) => {
    const uid = req.uid;
  
    try {
      const matchesSnapshot = await db.collection('matches')
        .where('users', 'array-contains', uid)
        .get();
  
      const matches = [];
  
      for (const doc of matchesSnapshot.docs) {
        const data = doc.data();
        const otherUserId = data.users.find((id) => id !== uid);
        const userDoc = await db.collection('users').doc(otherUserId).get();
        const userData = userDoc.data();
  
        // Find the chat between the two users
        const chatSnapshot = await db.collection('chats')
          .where('users', 'in', [[uid, otherUserId], [otherUserId, uid]])
          .limit(1)
          .get();
  
        let chatId = null;
        if (!chatSnapshot.empty) {
          chatId = chatSnapshot.docs[0].id;
        }
  
        matches.push({
          matchId: doc.id,
          user: userData,
          type: data.type,
          chatId: chatId,
        });
      }
  
      res.status(200).send({ matches });
    } catch (error) {
      res.status(400).send({ error: error.message });
    }
  });

// Outgoing Matches
// Get Outgoing Matches
app.get('/outgoingMatches', verifyToken, async (req, res) => {
    const uid = req.uid;
  
    try {
      const matchRequestsSnapshot = await db.collection('matchRequests')
        .where('from', '==', uid)
        .get();
  
      const outgoingMatches = [];
  
      for (const doc of matchRequestsSnapshot.docs) {
        const data = doc.data();
        const userDoc = await db.collection('users').doc(data.to).get();
        const userData = userDoc.data();
        outgoingMatches.push({
          requestId: doc.id,
          user: userData,
          type: data.type,
        });
      }
  
      res.status(200).send({ outgoingMatches });
    } catch (error) {
      res.status(400).send({ error: error.message });
    }
  });

  // Cancel Match Request
app.delete('/matchRequests/:requestId', verifyToken, async (req, res) => {
    const uid = req.uid;
    const requestId = req.params.requestId;
  
    try {
      const matchRequestRef = db.collection('matchRequests').doc(requestId);
      const matchRequestDoc = await matchRequestRef.get();
  
      if (!matchRequestDoc.exists) {
        return res.status(404).send({ error: 'Match request not found' });
      }
  
      const matchRequestData = matchRequestDoc.data();
  
      if (matchRequestData.from !== uid) {
        return res.status(403).send({ error: 'Unauthorized' });
      }
  
      await matchRequestRef.delete();
  
      res.status(200).send({ message: 'Match request canceled' });
    } catch (error) {
      res.status(400).send({ error: error.message });
    }
  });

// Delete Match
app.delete('/matches/:matchId', verifyToken, async (req, res) => {
  const uid = req.uid;
  const matchId = req.params.matchId;

  try {
    const matchRef = db.collection('matches').doc(matchId);
    const matchDoc = await matchRef.get();

    if (!matchDoc.exists) {
      return res.status(404).send({ error: 'Match not found' });
    }

    const matchData = matchDoc.data();

    if (!matchData.users.includes(uid)) {
      return res.status(403).send({ error: 'Unauthorized' });
    }

    await matchRef.delete();

    // Optionally delete the associated chat
    const chatsSnapshot = await db.collection('chats')
      .where('users', 'array-contains', uid)
      .get();

    chatsSnapshot.forEach(async (doc) => {
      const chatData = doc.data();
      if (chatData.users.includes(matchData.users[0]) && chatData.users.includes(matchData.users[1])) {
        await db.collection('chats').doc(doc.id).delete();
      }
    });

    res.status(200).send({ message: 'Match deleted' });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Get Chats
app.get('/chats', verifyToken, async (req, res) => {
  const uid = req.uid;

  try {
    const chatsSnapshot = await db.collection('chats')
      .where('users', 'array-contains', uid)
      .get();

    const chats = [];

    for (const doc of chatsSnapshot.docs) {
      const data = doc.data();
      const otherUserId = data.users.find((id) => id !== uid);
      const userDoc = await db.collection('users').doc(otherUserId).get();
      const userData = userDoc.data();
      chats.push({
        chatId: doc.id,
        user: userData,
      });
    }

    res.status(200).send({ chats });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Get Messages for a Chat
app.get('/chats/:chatId/messages', verifyToken, async (req, res) => {
  const uid = req.uid;
  const chatId = req.params.chatId;

  try {
    const chatRef = db.collection('chats').doc(chatId);
    const chatDoc = await chatRef.get();

    if (!chatDoc.exists) {
      return res.status(404).send({ error: 'Chat not found' });
    }

    const chatData = chatDoc.data();

    if (!chatData.users.includes(uid)) {
      return res.status(403).send({ error: 'Unauthorized' });
    }

    const messagesSnapshot = await chatRef.collection('messages')
      .orderBy('timestamp', 'asc')
      .get();

    const messages = messagesSnapshot.docs.map((doc) => doc.data());

    res.status(200).send({ messages });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

app.get('/verifyToken', verifyToken, (req, res) => {
    // If we reach here, the token is valid
    res.status(200).send({ isValid: true, message: 'Token is valid' });
  });

// Send Message in a Chat
app.post('/chats/:chatId/messages', verifyToken, async (req, res) => {
    const uid = req.uid;
    const chatId = req.params.chatId;
    const { text } = req.body;
  
    try {
      const chatRef = db.collection('chats').doc(chatId);
      const chatDoc = await chatRef.get();
  
      if (!chatDoc.exists) {
        return res.status(404).send({ error: 'Chat not found' });
      }
  
      const chatData = chatDoc.data();
  
      if (!chatData.users.includes(uid)) {
        return res.status(403).send({ error: 'Unauthorized' });
      }
  
      await chatRef.collection('messages').add({
        senderId: uid,
        text,
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
      });
  
      res.status(200).send({ message: 'Message sent' });
    } catch (error) {
      res.status(400).send({ error: error.message });
    }
  });
  

// Get Events
app.get('/events', verifyToken, async (req, res) => {
  try {
    const eventsSnapshot = await db.collection('events').get();
    const events = eventsSnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));

    res.status(200).send({ events });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Create Event (Admin only)
app.post('/events', verifyToken, verifyAdmin, async (req, res) => {
  const { title, description } = req.body;

  try {
    const eventRef = await db.collection('events').add({
      title,
      description,
      registeredCount: 0,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    res.status(200).send({ message: 'Event created', eventId: eventRef.id });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Delete Event (Admin only)
app.delete('/events/:id', verifyToken, verifyAdmin, async (req, res) => {
  const eventId = req.params.id;

  try {
    await db.collection('events').doc(eventId).delete();
    res.status(200).send({ message: 'Event deleted' });
  } catch (error) {
    res.status(400).send({ error: error.message });
  }
});

// Admin HTML interface
app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'admin.html'));
});

// Serve static files for admin interface
app.use('/static', express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));


// Start the server
const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\setAdmin.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend
Contents:
// setAdmin.js
const admin = require('firebase-admin');
const serviceAccount = require('./cltmeet-6bbce-firebase-adminsdk-l2mh4-004310ce36.json'); // Update the path if necessary

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

const email = 'admin@cltmeet.com'; // Replace with your admin user's email

admin
  .auth()
  .getUserByEmail(email)
  .then((user) => {
    return admin.auth().setCustomUserClaims(user.uid, { admin: true });
  })
  .then(() => {
    console.log(`User ${email} has been made an admin.`);
    process.exit();
  })
  .catch((error) => {
    console.error('Error making user admin:', error);
    process.exit(1);
  });

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\images\pJTbIlCjSWe7G33aD8QaQZS4tS12_1726701779110.jpg
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\backend\images
Contents:
ÿØÿÛ C 


		
%# , #&')*)-0-(0%()(ÿÛ C



(((((((((((((((((((((((((((((((((((((((((((((((((((ÿÀ  – –" ÿÄ              ÿÄ C 	    !1A"Qaq2Á‘¡±#Ñ3R’áğ$4Brâ&CEb¢²ÒñÿÄ               ÿÄ )        !1A2Q3q#’±ÁÿÚ   ? Ìşğ+OëuØ‘uŠeƒ
\o·/JÑbà<.XfWáöeuàÕå~Æ&í˜nªQö£YGşÎ¤ó,Çõ5¼ƒ‘ºì ¸%›‡Z¯_”?¡W7ÃNÏM,jÜC¨ü9ß5¡Ü!ÀÆ6¨aŒş.- gXê*I.–ÂIYœOğ…»oÄï#<ğêüª®ãàİÆOá¸ÄLGI #ö&¶Ãf¦f”iÖÀ)#$œrıÍ)b
Jÿ f[Ÿ=¿:åyÓ]Æ({?Üü"ãÑ“ÜÏa6<¤eıÅU\ü6í<ùzÊ<â™ï_JÇˆ•µ á”Æ	Àö>õ	Be# =|Á©÷È‰òíÏcûCl	—ƒ_ :¬E¿lÕdü2úßû{+¨ÿ ç…‡Ú¾µ59ˆzrº·•5RFKV*5†m†ÛãÎî_t»3ä"¥Ncëµ 3Ê¾²ÎÚáˆšÖÈ2F¬ş£İŒà·³è~`ÌF@1*“¶yŠ¿¹]Ğ/÷>XÒib¾’ºøuÙiU¸RFH'1Hë÷ªçøSÙ{…v…ï¡ÒJä9üÀÖ‹<X/Ÿ±]Ån?8X4<VùB©`¯6¬ã;TŸöaÀ.¬m'F¼·ya
¦92	Ç?5¤f¥Áœ¢ãÉ†]Åk×_	m²Å'_.öoØŠ©¹øSÄÓıŞşÒ_FVC÷¢Î ¥^Î‡=¢ˆám ”y¤ë÷Å*…OÁCÛq™Ø4ØëµhÜ9GàaØŸz×…ø(;Ê^Èq‡™óŸ@+Ş[ [8A#ä^xò¦cÁ´V†N¬#ÜTV±«İÆ	ÛsúTÓáàÒ™aŸÇG@?*™=ôVËOÃ¢‚ÁF¶ œñÒ kD¸SÄ
rX·J#Xy]7Ø«c‘CÅ,W0‰£Ã®“qö®#{ää¶Ëo‹Q‰•‚ildc¡Ï]ºo\jÒkÖ9Ó¹çšìÇ$q™|D0uÿ ›;( ±¶˜ó“»ãq·,ùzUil§°Yağ‹“Œ’Ù>~Â¢Ğ­¸ˆ¹’EP5G©8¢#ˆG+6ÄAÃaDÄÊ¥Ùã,4àÄäsçûÔ#ßÄÀ_L•+‹p»ÛÄîá6ğ57\ÒˆCpI„ĞCF6ÈÁü©îä)*ÚÎ06ù}(Ê#ü:’txyêl@ZdvË¾4ì|GÁûÑhGtÅÏ‹HÒÏ­ í!a§ `)ÏN»U¦áI63&¥Aç¶j°°Å7
áÌŠà,°{îº¿_«Gb’ÅˆÙÃH# óö¨»‹,0ñYñ‰cof~_“S8Eóöawü"×[\Œí¶*¢~ƒäÏçZ=ÍŒNÛæ€›…ÆsÚ˜03ÇáÀ˜Ò¯nü9åŸaJ¡f=ğª>ëáî¼Jİ|Í{xü Ò~P9«Ê|?·1ü7±bÑ–üÚ½[&9`\©¸ğj¸•Fäõõ¦ØŸö°Ê!N9yT²
.GŸ¾Çè+–D÷Î9xÎü¨s~9~ƒ(°Y£BB€NA:d÷"Ú'œ6R1¨”RÕ#C§æÆÄïïJ=JåºœüÏ¦õÁ»İüw‚Q²‚Ië¹õé½&+ŞªãÆ3|Ó'–CéuyjTdj<ˆ©»¥g2›#*$Óœzg¦|½*Å
s©¤ÔŞyòéP„Šò%Rñ³Ö¯¹*|ıèƒ#H4´¥„#N’I+Ôt¦Á¬dB£F’1ä:‘­.èsF{Åa+´wò<ñËjlhc•‹0dÕ¨©ğíåŸ½)r².©0\xWV3!ÖÌîVwe\…S¾çƒF'.rÚDR4K¨zü9>~tü¨`AÉm±¾~ÔÛ(c†„/zˆ Ä“·#µs[€ºé1ıè#íÌ«´¥e$6“€yã¥?±ØVíL@oÜW#ê ı¨yÖY-Ü,º%#ÂBò4_c”7iûCj£iì"æ2´ÆL3ñfŠB–làœ×”í×kl{-näˆ½”ºœdyEıúUÏâ‘p~qÄîAhà„HTscõ$
ù·‹_^q¾!q}}!’æS©‰ØĞäJhRN‡ñŞÔqÎ1tf¹¿¸EÉÓcD@úœšUZa,vÛÜÒ¢Í³÷…áPï“CY#Ö®ß³¾ÿ 7?Ö‚³^çğ˜9ÄcòEÅÊ[Û™.$XãLflŞš\!’F‡p}N1]±Eïd ”à·¸ª»nÒpÛû¦¶³º‰ä^¹¸ßzµ±e’I0m€9ıë/ÿ …CTo…]ÀÛ´d¶pqÏ~´•ØÆŠycúW#ßV ¾1¿¿ë\f04°p¸ÎØ©Ie=Ş¢ªpØèOµW_ZİÜJZÖé s(Ë ‡É:yn»TÓŠ-äku›—ÓÜ¸á@U9m’Z”™V[…Û 
LwlzTÑJñÊgI$Ha·J£.·òäÔÎXàìr7ÁÓêE=ŠÄ[4ä(b£@ÉïAÏR˜ÇLç=*ºQ,²1Äó+´j]	Ğz‚Fôó  YF¬sóª‘ı.×æ•ó©AÔ˜ğ^§~yéM·ŸŒ¤±¬öÈPG?…A@Ö}¶çšµº‹‹` e#nxôÈ¦*‚ıæû¸ÎŞ|ª­n¸¯à¬–(nX\¯0°AØÎwò£ìä™­­Úä(™Ğ4šy+cqWÒ‘.ÉæhZ=Er…u'OZ“²Àø
'¿áyjÒÀÔgqÔ¹S8C÷]¾ìóòwĞşj
o‹Ôe—ÒñZùÿ ªÜ;‡D»İ¾d8ä±_SÊ²w±Ñ¥ƒêúÔ¾3Û´\;…O@†æX[Èj·ügÜÒãŠ_Çkk’B*r;Ó4Û•Ù\`}©V§qğÎşÖÜ˜‰;«84¨úX6‘V[JXÆAÛE¯ñ.+©–Ü¦¿À¢36•/‘ó6Û‘;s¯_q‡º·L…l.CÊ›y
\[Mip¡­æFÔm•#TÔ•ªjÑ‡ğÛÛnÅíîÜ¼í	-¥<;ã}ëbì—·ã6
sn_CaY\`ƒÇ:ñwŸ¢’õä<^cœò,¿ÔçZö½–áÖÜ&ÌZZ+Pç,|LNrIó4®e(ã•“jG 4‚~lo¿Jê°êöÌÔ/ ÆG"
H%[v÷ÈÊY°	 ¹ôô¯#Úâcµ.ŞÓ‹ŞÚÃ~d$E+„ló×5ë¤ÉÀ#ndv_ÂVç‰ğÛçiD¶eÊ ¨`æ®2¦•¢·} »áwv)ÃIÂ#]] Ì*UwÈõ5?l¸´¼8p–´¿p]JË$ı×}…•:zı<ê^-Ù/Å&»â-<šíÖŒ1Q3¸ÁÜäò;QPv|2ğ7R—á/©\ Ì¸R¾/-±Ê‰J:©l§^ĞqêDÜAÔîû¸¶“»*³åÂ«„<³“·¥L{EÄ%ìô´
x„~€ME_L sÓÏkÚ>œzŞÚŞi¤Ş9–i{3…Îäns‘åCp®Í?	°â6ü?‰M\È^3¹ù·Ş¢”h•+ìõÜ—¼2¦½³½.	Ú©TaÓÂy1Òem€ØrçŠ©ì×nmr³]-Ä÷S™ädˆFºŞaµZü©©q±ååTêôZºØà8lÌ_:ânçözädïĞg Š)üNyn3Ê«{FÅm-¦hnbryrp>õ¦7M‘\Y§q~àünÂè„÷ŠTn¬ \ŠÄxMÍÇ¸BÅ:n§[õ¯ ¸aÕÅnâGŸ¸£8Ÿ´ºM¶ğÜ/A*ıéÔÄZ³#·í¿NîkÉ™o¿Ö•hÖ]˜àÖ…šß‡&[¦fL©TØ=S#ÄHñ9Û#˜ô©%è1ì?•00ké0È@7#}Ï­riB¡ ŸQüéá°i±ë¾s½ÃT°bN ==¨&:¹ò£ùÑü7I‰ˆ‰Æ7ß¿‹üL8rB©PvÁJc[ÂüáÎye˜}éçÁ,à¶3ü©É!ÛWŒÿ EÚ0! $ö‘Çìj6á¼+*®X1bª? $ÈW09Ñ2ºÛÇ$³x,ÇÓ¯;0àQÄóI-Üq†ïÈ:ˆ&P¹9<Ê’-^¸«VÁ–‹cÂøHH¥È©&YX_I†P2H:÷ oš”ğ€«<êûäş>^„ÿ ™Ç¹ÖÜ0w<:âiÕ¢„°›$§AÉÇ"Xl1Óm¨i8_´±ÒkÄU2ÛFW,wrÌNÇ8eÎôÔù+à°“…Y ÿ {»_\ş>P5gåÎ¬gÒ¦ş±2×—‘£då¸Œ€9ï«¥
ßÑòZ2]~&h{é/N¸ÉL!ñ±ÀRÄãÌíBM	™¥¸º’(RPŠb³/y€1¾Ü½@i?r‹glXÇíŞ°HÇãœ±Ó>¢–avï®ˆ=
Ãªµ¸áIÄ»È.%3‰Œ¬ºywØØí9ÁÜìjø¹:‹
;ìEG¢Õ3°¦”ùä#flíUİ¥Pı½ `Æ€aÍ¿)PNyyf‡âÑáW©Ì.6ö4Q{EIišœ™lgCıµ9üŞ®Ë’I¯-ÙŒİìÜùùíôğÿ •z`)ä"J$lc'©"©ù›JUd1(ŸUİÁbr4ŒçşªkÉJI#ÌŸúª+pÚ®vù€yíO”ÿ }Yöl~Ôò7’Br	À½ÅGY+]ŠîNI>Ş¦«ä
œåÆ=è¸˜Abd”ˆ‰9ä<©_¬F¸•Ê‹Î a‘ŒrØS´áğ YÚ ïÀ²®C.HÛ™š]	’FÓëö®;iroDÓ„’7A­e<ˆ#~´,œ>Îi¥2ZÄıàU}\1¤}09y*- 2G#gV“Ôù_°5 eFXÊêÛU^ôN›9'
³º”ÉqrÈW»yñi g6©ZÆÉáhZİ"ıî†RpÙÎ}ÿ ÎªëJë¤>ß•Ekt³5ÀV,cÆŞãjEUŒ“‡Y,mbe}dämãù¿>£•5xm’,˜´BcNÚ@#ĞGÔÔ’Èğ¯y,w÷`³DñÃÜs©†©T²1pàyŸ!S¯¹n5 Fá–,®‘ÚÂ*¡Êï…ÁØ`~U8äp¹wzT¥]í^uh°¯¥”0è(`Ò~"B jR yÿ \½(º“‰4Üœ
S“$L›éu+ÏÓüê;i¤¹âd“÷Mç“çŠâk(Ó˜Ëe›û´I¢šìz¿‡÷‡à¬NğÎb?™z÷`VkğÕôöOˆÃÖÖø<†¯ò­XAÁ;Šè#Áğ1°?ZTOr3Œæ•YŸ-Š‘&’ mò¾tùÂh]:ùÛÊ•™oÃ)Ë}Îœò°ËduÉştøÀ; ;oËaÿ Ö¬,•ØkBú²4éÎ¡íµV3;ìGRrùQöxxJê(
éVÀó—ü&¸¹
·i5â$eÀØ/<cµE#¤k—eMLkóè=êLio”õAÇúÍC4I,“x‚Êsæ9W"ìaQ2HÊ†Ræ(¬BìHÕä6ëÖ¸Ó2Èuc#˜ØW.#YN§P¸äøõcË­FB´ñÊÛÊªUpyƒÏö4÷e
õWÓıí;{Ëè*(î£’YaVËÆÀ8ÒF	<O,ÓHõÉ¡NU5)=qÊ˜ª#'Œäî7Çÿ µÎ;23k Y-Ë¦şT¡Q$ºRH`nà.Ã8ÉëûÒ˜$HK šrX¦‡Ex¤jÈÜõEu²Rç±Æ•òu;Rm‡Z!£•THc=Ó·&#=¾õÆñKÜŒŒûÓ¤I í ©$iÏˆrß[Ñ]FZ7=à•Î€Î<ö¨æ£xÊÅ#£ºÆp09ÜşU"?|äE¥Š¶œ¸>UäÂËø’1 FÇ©ÇZ8ß6M]QsğàŸûÕkå'x¸'ïZ­Ë=¼M« ¢ŸÒ²¯‡2ë€ì%¶F@i\‰8e³a4Ÿ¦Ôü89òÓaæ]ó“J¢#}¶¥F	„Z¦-£\Gœm¿Î¸è§˜O¦ŸåRZƒÜGyÒrlSœ99ñ7=>0ù;ò#öÿ 
ZÛ2ÇkL¸#'¯J©›˜Õ«g?sV(ŒmF†ÁtøI3ÈÒQ¯.™¶P`ÕàÃi|Õæ<>Şâkiáœ!*PåClFüùtŞƒ¿7ØgøšÓQ`1§;ıjwA‚€6Ç?¦Â¹MroìÈ$µüDöÎìBÁ!q·˜şU<(Yá‰¤È+#ƒ©@è‘ëíM7|B¨<åõ®¦¢¡N€	ÏË–úíYËõÜˆZNòø»Â¡ùgËÎ§r
–	3s!0Xã Ÿ3µB¯6Kİc ¾ªä…ÌˆLš”|ªØ>ı~µ{µ¢şB/§k­OtáÁ]> ÀoÊ…µ–íÃEÜµ¹@à2éÆØÎsL†Õ¬Õ„2³3HÒg8 “štÑ¼–ì“O#ÈÛ™gè0?*ºwU ].édDdÕ oáÉ'Ò¸ÓâeÜåòQ5s zdT±Í,1È#}*ë¥°€íõ}(R#i}:Õp¬yoõÒŒ¡ìú˜åú€w¥2Úåg‰eWR¬6b1¾pw>´ùº¡nJN0 gëK[®4,q¨Ö00^TJÊtØ©Ò/‰&¡››3Î	­7÷%uÿ İşu’ğ	‡õÿ ³óEƒ«¦­C–Äcó­zÉtÏzƒş³ù€iì~”#•T˜viWÒ­Ì.6ÂÇâæ1ÈŸ½C#®6ûxØúÒ¥]„Ìšˆ\’6ùT}«ÑYA#„Œ0Â®wô\Ò¥\ß©6 š6ÅÈ S)#Vàjßß
ıçáÍ¢g&sòƒ¾Ô©W!I¹É{PÔ"›VÑëPâV@® ®€Úó·2vßj],wpF2½änÀ(ğóÏø‡ëJ•c‡$§—$[Òj¿¬_úÊq])‡ÇTÊúÙ˜´
 º³œúcëA¢ÏßÜLò+BÚV8ñò•ÎO×#ò¥J´ri¤»¿øRß$²±ã  tŒ[ŸÖÒÇ*ºÌ¡ƒ
Q9ÿ —éJ•^&ÜU’Z`×ñè×½!\J²jM²ug—•NvàÂÙğ»óŒó:}éR­ÔS3ll ¬ŠÅØëQĞ:F1:É’®®g?*Tj*Ê¶WKpñîÌË’%†óHq Øù«q„iâW`uCJ•7‹Ò'—ra¼©R¥Z™ÿÙ

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\context\AuthContext.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\context
Contents:
import React, { createContext, useState, useEffect } from 'react';
import { Alert } from 'react-native';
import { auth } from '../firebaseConfig';
import * as SecureStore from 'expo-secure-store';
import axiosInstance from '../api/axiosInstance';




// Create AuthContext
export const AuthContext = createContext();

// AuthProvider Component
export const AuthProvider = ({ children }) => {
  const [userToken, setUserToken] = useState(null);
  const [loading, setLoading] = useState(true);
  

  // Load token from SecureStore when app starts
  useEffect(() => {
    const loadToken = async () => {
      try {
        const token = await SecureStore.getItemAsync('userToken');
        if (token) {
          setUserToken(token);
          axiosInstance.defaults.headers.Authorization = `Bearer ${token}`;
        }
      } catch (error) {
        console.error('Error loading token:', error);
      } finally {
        setLoading(false);
      }
    };

    loadToken();
  }, []);

  // Login function
  const login = async (email, password) => {
    try {
      const response = await axiosInstance.post('/login', { email, password });
      const { token } = response.data;

      if (token) {
        await SecureStore.setItemAsync('userToken', token);
        setUserToken(token);
        axiosInstance.defaults.headers.Authorization = `Bearer ${token}`;
      }
    } catch (error) {
      console.error('Login error:', error);
      Alert.alert('Login Failed', error.response?.data?.error || 'An error occurred during login.');
      throw error;
    }
  };

  // Logout function
  const logout = async () => {
    try {
      await SecureStore.deleteItemAsync('userToken');
      setUserToken(null);
      delete axiosInstance.defaults.headers.Authorization;
    } catch (error) {
      console.error('Logout error:', error);
      Alert.alert('Logout Failed', 'An error occurred during logout.');
    }
  };

  return (
    <AuthContext.Provider value={{ userToken, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\ChatListScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// ChatListScreen.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native';
import axiosInstance from '../api/axiosInstance'; // Use axiosInstance instead of axios
import AsyncStorage from '@react-native-async-storage/async-storage';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '../firebaseConfig';

export default function ChatListScreen({ navigation }) {
  const [chats, setChats] = useState([]);
  const [token, setToken] = useState('');
  const [registeredEvents, setRegisteredEvents] = useState({});

  useEffect(() => {
    const fetchChats = async () => {
      const storedToken = await AsyncStorage.getItem('userToken');
      setToken(storedToken);

      try {
        // Fetch chats from backend using axiosInstance
        const response = await axiosInstance.get('/chats');
        let chatsData = response.data.chats;

        // Add Charlotte group chat
        const groupChatDocRef = doc(db, 'groupChats', 'charlotteGroupChat');
        const groupChatDoc = await getDoc(groupChatDocRef);
        if (groupChatDoc.exists()) {
          const groupChatData = {
            chatId: 'charlotteGroupChat',
            name: 'Charlotte Group Chat',
          };
          chatsData = [groupChatData, ...chatsData];
        }

        // Fetch user's registered events using axiosInstance
        const userProfileResponse = await axiosInstance.get('/getUserProfile');
        const userRegisteredEvents = userProfileResponse.data.registeredEvents || {};
        setRegisteredEvents(userRegisteredEvents);

        // Add event chats
        const eventChats = [];
        for (const eventId of Object.keys(userRegisteredEvents)) {
          // Fetch event details from Firestore
          const eventDocRef = doc(db, 'events', eventId);
          const eventDoc = await getDoc(eventDocRef);
          if (eventDoc.exists()) {
            const eventData = eventDoc.data();
            const eventChat = {
              chatId: `event_${eventId}`,
              name: eventData.title,
            };
            eventChats.push(eventChat);
          }
        }

        // Combine all chats
        chatsData = [...eventChats, ...chatsData];

        setChats(chatsData);
      } catch (error) {
        console.error('Error fetching chats:', error);
      }
    };

    fetchChats();
  }, []);

  const renderItem = ({ item }) => (
    <TouchableOpacity
      style={styles.chatItem}
      onPress={() => navigation.navigate('Chat', { chat: item })}
    >
      <Text style={styles.name}>{item.user ? item.user.name : item.name}</Text>
      <Text style={styles.lastMessage}>Tap to chat</Text>
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      {chats.length > 0 ? (
        <FlatList
          data={chats}
          keyExtractor={(item) => item.chatId}
          renderItem={renderItem}
        />
      ) : (
        <Text>No chats yet.</Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
  },
  chatItem: {
    padding: 15,
    borderBottomWidth: 1,
  },
  name: {
    fontSize: 18,
  },
  lastMessage: {
    fontSize: 14,
    color: 'gray',
  },
});


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\ChatScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// ChatScreen.js

import React, { useState, useEffect, useContext, useCallback, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Keyboard,
  TouchableWithoutFeedback,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { db } from '../firebaseConfig'; // Ensure this path is correct
import {
  collection,
  addDoc,
  onSnapshot,
  query,
  orderBy,
  serverTimestamp,
  doc,
  getDoc,
  updateDoc,
} from 'firebase/firestore';
import { AuthContext } from '../context/AuthContext'; // Ensure AuthContext is correctly set up
import jwtDecode from 'jwt-decode'; // Import jwt-decode

export default function ChatScreen({ route, navigation }) {
  const { chat } = route.params; // chat should contain chatId and name
  const [messages, setMessages] = useState([]);
  const [inputText, setInputText] = useState('');
  const [usersCache, setUsersCache] = useState({});
  const { userToken, loading, logout } = useContext(AuthContext); // Use AuthContext
  const [currentUserUid, setCurrentUserUid] = useState(null); // State for UID
  const [loadingMessages, setLoadingMessages] = useState(true);
  const flatListRef = useRef(); // Reference to FlatList for scrolling

  // Decode JWT to extract UID
  useEffect(() => {
    if (loading) {
      console.log('AuthContext is loading...');
      return;
    }

    if (!userToken) {
      console.log('User not authenticated');
      Alert.alert('Authentication Error', 'You are not authenticated.', [
        { text: 'OK', onPress: () => navigation.replace('Login') },
      ]);
      return;
    }

    try {
      const decodedToken = jwtDecode(userToken);
      if (decodedToken && decodedToken.uid) {
        setCurrentUserUid(decodedToken.uid);
        console.log('Extracted UID from token:', decodedToken.uid);
      } else {
        console.warn('Failed to extract UID from token');
        Alert.alert('Authentication Error', 'Invalid authentication token.', [
          { text: 'OK', onPress: () => navigation.replace('Login') },
        ]);
        return;
      }
    } catch (error) {
      console.error('Failed to decode JWT:', error);
      Alert.alert('Authentication Error', 'Invalid authentication token.', [
        { text: 'OK', onPress: () => navigation.replace('Login') },
      ]);
    }
  }, [userToken, loading, navigation]);

  // Set up Firestore listener for messages
  useEffect(() => {
    if (!currentUserUid) return;

    console.log('Setting up Firestore listener for chat:', chat.chatId);

    const messagesRef = collection(db, 'chats', chat.chatId, 'messages');
    const q = query(messagesRef, orderBy('timestamp', 'asc'));

    const unsubscribe = onSnapshot(
      q,
      (querySnapshot) => {
        console.log('Received new messages snapshot');
        const msgs = [];
        querySnapshot.forEach((doc) => {
          const data = doc.data();
          // Validate senderId
          if (data.senderId && data.text && data.timestamp) {
            msgs.push({ id: doc.id, ...data });
          } else {
            console.warn('Invalid message data:', data);
          }
        });
        setMessages(msgs);
        setLoadingMessages(false);
        // Scroll to bottom when new messages arrive
        if (flatListRef.current) {
          flatListRef.current.scrollToEnd({ animated: true });
        }
      },
      (error) => {
        console.error('Error fetching messages:', error);
        Alert.alert('Error', 'Failed to load messages.');
        setLoadingMessages(false);
      }
    );

    return () => {
      console.log('Unsubscribing from messages snapshot');
      unsubscribe();
    };
  }, [chat.chatId, currentUserUid]);

  // Function to send a message
  const sendMessage = async () => {
    console.log('sendMessage triggered with inputText:', inputText);
    if (inputText.trim() === '') {
      console.log('Attempted to send empty message');
      return; // Prevent sending empty messages
    }

    if (!currentUserUid) {
      console.log('currentUserUid is not set');
      Alert.alert('Error', 'You are not authenticated.');
      return;
    }

    try {
      const messagesRef = collection(db, 'chats', chat.chatId, 'messages');
      const newMessage = {
        senderId: currentUserUid, // Ensure this is the UID
        text: inputText.trim(),
        timestamp: serverTimestamp(),
      };
      console.log('Adding message to Firestore:', newMessage);
      await addDoc(messagesRef, newMessage);

      // Correctly update the lastMessage field in the chat document
      const chatRef = doc(db, 'chats', chat.chatId);
      const lastMessage = {
        text: inputText.trim(),
        senderId: currentUserUid,
        timestamp: serverTimestamp(),
      };
      console.log('Updating lastMessage in Firestore:', lastMessage);
      await updateDoc(chatRef, { lastMessage });

      setInputText(''); // Clear input field after sending
      console.log('Message sent successfully');
    } catch (error) {
      console.error('Error sending message:', error);
      Alert.alert('Error', 'Failed to send message.');
    }
  };

  // Function to get user name by UID with caching
  const getUserName = useCallback(
    async (uid) => {
      console.log('Fetching user name for UID:', uid);
      if (usersCache[uid]) {
        console.log('User name found in cache:', usersCache[uid].name);
        return usersCache[uid].name;
      } else {
        try {
          const userDocRef = doc(db, 'users', uid);
          const userDoc = await getDoc(userDocRef);
          if (userDoc.exists()) {
            const userData = userDoc.data();
            setUsersCache((prev) => ({ ...prev, [uid]: userData }));
            console.log('Fetched user data from Firestore:', userData);
            return userData.name;
          } else {
            console.warn('User document does not exist for UID:', uid);
            return 'Unknown';
          }
        } catch (error) {
          console.error('Error fetching user name:', error);
          return 'Unknown';
        }
      }
    },
    [usersCache]
  );

  // Component to render individual messages
  const MessageItem = React.memo(({ item }) => {
    const isMyMessage = item.senderId === currentUserUid;
    const [senderName, setSenderName] = useState('Loading...');

    useEffect(() => {
      let isMounted = true; // To prevent state update on unmounted component

      const fetchName = async () => {
        // Validate senderId format (assuming UIDs are alphanumeric and of specific length)
        if (!item.senderId || item.senderId.length < 10) { // Adjust length as per your UID structure
          console.warn('Invalid senderId detected:', item.senderId);
          if (isMounted) {
            setSenderName('Unknown');
          }
          return;
        }

        const name = await getUserName(item.senderId);
        if (isMounted) {
          setSenderName(name);
          console.log('Sender name set to:', name);
        }
      };

      fetchName();

      return () => {
        isMounted = false;
      };
    }, [item.senderId]);

    return (
      <View
        style={[
          styles.messageBubble,
          isMyMessage ? styles.myMessage : styles.theirMessage,
        ]}
      >
        {!isMyMessage && (
          <Text style={styles.senderName}>{senderName}</Text>
        )}
        <Text style={styles.messageText}>{item.text}</Text>
      </View>
    );
  });

  // Render each message item
  const renderItem = ({ item }) => <MessageItem item={item} />;

  // Key extractor with fallback
  const keyExtractor = (item) => item.id || Math.random().toString();

  // Show loading indicator while messages are being fetched
  if (loading || loadingMessages) {
    console.log('Loading messages...');
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007aff" />
        <Text>Loading messages...</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
    >
      <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
        <View style={styles.inner}>
          {/* Chat Header */}
          <View style={styles.header}>
            <Text style={styles.headerText}>{chat.name}</Text>
          </View>

          {/* Messages List */}
          <FlatList
            ref={flatListRef}
            data={messages}
            keyExtractor={keyExtractor}
            renderItem={renderItem}
            contentContainerStyle={styles.messagesContainer}
            showsVerticalScrollIndicator={false}
            onContentSizeChange={() => flatListRef.current.scrollToEnd({ animated: true })}
            onLayout={() => flatListRef.current.scrollToEnd({ animated: true })}
          />

          {/* Message Input */}
          <View style={styles.inputContainer}>
            <TextInput
              value={inputText}
              onChangeText={setInputText}
              placeholder="Type a message"
              style={styles.input}
              multiline
              onSubmitEditing={sendMessage}
              returnKeyType="send"
            />
            <TouchableOpacity
              onPress={sendMessage}
              style={[
                styles.sendButton,
                { opacity: inputText.trim() ? 1 : 0.5 },
              ]}
              disabled={!inputText.trim()}
            >
              <Text style={styles.sendButtonText}>Send</Text>
            </TouchableOpacity>
          </View>
        </View>
      </TouchableWithoutFeedback>
    </KeyboardAvoidingView>
  );
}

// Styles for the ChatScreen component
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f7f7f7',
  },
  inner: {
    flex: 1,
  },
  header: {
    padding: 15,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderColor: '#eee',
    alignItems: 'center',
  },
  headerText: {
    fontSize: 20,
    fontWeight: '600',
  },
  messagesContainer: {
    flexGrow: 1,
    paddingHorizontal: 10,
    paddingVertical: 5,
  },
  messageBubble: {
    maxWidth: '75%',
    padding: 10,
    borderRadius: 20,
    marginVertical: 5,
  },
  myMessage: {
    backgroundColor: '#dcf8c6',
    alignSelf: 'flex-end',
    borderTopRightRadius: 0,
  },
  theirMessage: {
    backgroundColor: '#fff',
    alignSelf: 'flex-start',
    borderTopLeftRadius: 0,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
    elevation: 1,
  },
  senderName: {
    fontSize: 12,
    color: 'gray',
    marginBottom: 3,
  },
  messageText: {
    fontSize: 16,
    color: '#333',
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 10,
    backgroundColor: '#fff',
    alignItems: 'flex-end',
    borderTopWidth: 1,
    borderColor: '#eee',
  },
  input: {
    flex: 1,
    maxHeight: 100,
    paddingVertical: 10,
    paddingHorizontal: 15,
    backgroundColor: '#f1f1f1',
    borderRadius: 20,
    fontSize: 16,
  },
  sendButton: {
    marginLeft: 10,
    backgroundColor: '#007aff',
    borderRadius: 20,
    paddingVertical: 10,
    paddingHorizontal: 20,
    justifyContent: 'center',
  },
  sendButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\ChatStack.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// screens/ChatStack.js
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import ChatListScreen from './ChatListScreen';
import ChatScreen from './ChatScreen';

const Stack = createNativeStackNavigator();

export default function ChatStack() {
  return (
    <Stack.Navigator>
      <Stack.Screen name="ChatList" component={ChatListScreen} options={{ title: 'Chats' }} />
      <Stack.Screen name="Chat" component={ChatScreen} />
    </Stack.Navigator>
  );
}

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\EventsScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// EventsScreen.js
import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, TouchableOpacity, Image, StyleSheet, Alert, Button, Share, Animated } from 'react-native';
import axiosInstance from '../api/axiosInstance'; // Use axiosInstance instead of axios
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useIsFocused } from '@react-navigation/native';

export default function EventsScreen({ navigation }) {
  const [events, setEvents] = useState([]);
  const [registeredEvents, setRegisteredEvents] = useState({});
  const [token, setToken] = useState('');
  const isFocused = useIsFocused();
  const fadeAnim = new Animated.Value(0); // For fade-in animation

  useEffect(() => {
    if (isFocused) {
      fetchEvents();
      // Start the fade-in animation
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true,
      }).start();
    }
  }, [isFocused]);

  const fetchEvents = async () => {
    const storedToken = await AsyncStorage.getItem('userToken');
    setToken(storedToken);

    try {
      const response = await axiosInstance.get('/events');
      setEvents(response.data.events);

      const userProfileResponse = await axiosInstance.get('/getUserProfile');
      setRegisteredEvents(userProfileResponse.data.registeredEvents || {});
    } catch (error) {
      console.error('Error fetching events:', error);
    }
  };

  const registerEvent = async (eventId) => {
    try {
      await axiosInstance.post('/registerForEvent', { eventId });
      Alert.alert('Registered', 'You have registered for the event.');
      fetchEvents(); // Refresh events
    } catch (error) {
      console.error('Error registering for event:', error);
    }
  };

  const openEventChat = async (event) => {
    const chatId = `event_${event.id}`;
    const chatName = event.title;

    const chatData = {
      chatId: chatId,
      name: chatName,
    };

    navigation.navigate('Chat', { chat: chatData });
  };

  const shareEvent = async (event) => {
    try {
      await Share.share({
        message: `Check out this event: ${event.title} happening on ${event.time}!`,
      });
    } catch (error) {
      Alert.alert('Error', 'Could not share the event.');
    }
  };

  const renderItem = ({ item }) => (
    <Animated.View style={{ ...styles.eventCard, opacity: fadeAnim }}>
      <TouchableOpacity onPress={() => Alert.alert(item.title, item.description)}>
        <Image source={{ uri: item.imageUrl || 'https://via.placeholder.com/150' }} style={styles.eventImage} />
        <View style={styles.eventContent}>
          <Text style={styles.title}>{item.title}</Text>
          <Text style={styles.details}>ğŸ“ {item.distance || '5 miles away'}</Text>
          <Text style={styles.details}>â° {item.time || '2 PM'}</Text>
          <Text style={styles.details}>ğŸ“… {item.date || 'Sept 30, 2024'}</Text>
          <Text style={styles.details}>Registered Users: {item.registeredCount || 0}</Text>
        </View>
      </TouchableOpacity>
      <View style={styles.actionButtons}>
        <TouchableOpacity style={styles.shareButton} onPress={() => shareEvent(item)}>
          <Text style={styles.shareText}>Share</Text>
        </TouchableOpacity>
        {!registeredEvents[item.id] ? (
          <Button title="Register" onPress={() => registerEvent(item.id)} />
        ) : (
          <Button title="Chat" onPress={() => openEventChat(item)} />
        )}
      </View>
    </Animated.View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.header}>CLTMEET</Text>
      <FlatList
        data={events}
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        numColumns={1}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F0F8FF',
    paddingHorizontal: 10,
    paddingTop: 10,
  },
  header: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#ff6347', // Tomato color for a pop of color
    textAlign: 'center',
    fontFamily: 'Recoleta', // Unique font for CLTMEET
    marginBottom: 20,
  },
  eventCard: {
    backgroundColor: '#FFF',
    borderRadius: 15,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 3,
    transition: 'all 0.3s ease',
  },
  eventImage: {
    width: '100%',
    height: 200,
    borderRadius: 10,
    marginBottom: 10,
  },
  eventContent: {
    marginBottom: 15,
  },
  title: {
    fontSize: 20,
    fontWeight: '700',
    color: '#333',
    marginBottom: 5,
  },
  details: {
    fontSize: 14,
    color: '#888',
    marginBottom: 3,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 10,
  },
  shareButton: {
    backgroundColor: '#ff6347',
    paddingVertical: 5,
    paddingHorizontal: 15,
    borderRadius: 10,
  },
  shareText: {
    color: '#FFF',
    fontWeight: '600',
  },
});


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\LoginScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// screens/LoginScreen.js

import React, { useContext, useState } from 'react';
import { View, TextInput, Button, StyleSheet, TouchableOpacity, Text, Alert, ActivityIndicator } from 'react-native';
import { AuthContext } from '../context/AuthContext';

const LoginScreen = ({ navigation }) => {
  const { login, clearStorage, loading } = useContext(AuthContext);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = () => {
    if (email.trim() === '' || password.trim() === '') {
      Alert.alert('Error', 'Please enter both email and password.');
      return;
    }
    login(email, password);
  };

  if (loading) {
    return (
      <View style={styles.loaderContainer}>
        <ActivityIndicator size="large" color="#FF3B30" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>CltMeet2 Login</Text>
      <TextInput
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        style={styles.input}
        autoCapitalize="none"
        keyboardType="email-address"
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        style={styles.input}
        secureTextEntry
      />
      <Button title="Login" onPress={handleLogin} />
      <TouchableOpacity onPress={() => navigation.navigate('SignUp')}>
        <Text style={styles.link}>Don't have an account? Sign Up</Text>
      </TouchableOpacity>
      <View style={styles.separator} />
      <Button title="Clear Storage" onPress={clearStorage} color="#FF3B30" />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#fff',
    justifyContent: 'center',
  },
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    marginBottom: 30,
    textAlign: 'center',
    fontWeight: 'bold',
    color: '#FF3B30',
  },
  input: {
    height: 50,
    borderColor: '#ccc',
    borderWidth: 1,
    marginBottom: 15,
    paddingHorizontal: 15,
    borderRadius: 8,
  },
  link: {
    color: '#1E90FF',
    marginTop: 15,
    textAlign: 'center',
    fontSize: 16,
  },
  separator: {
    height: 20,
  },
});

export default LoginScreen;


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\MainTabs.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

import EventsScreen from './EventsScreen';
import SwiperScreen from './SwiperScreen';
import MatchesScreen from './MatchesScreen';
import ChatStack from './ChatStack';
import ProfileScreen from './ProfileScreen';

const Tab = createBottomTabNavigator();

export default function MainTabs() {
  return (
    <Tab.Navigator
      initialRouteName="Swiper"
      screenOptions={{ headerShown: false }}
    >
      <Tab.Screen name="Events" component={EventsScreen} />
      <Tab.Screen name="Swiper" component={SwiperScreen} />
      <Tab.Screen name="Matches" component={MatchesScreen} />
      <Tab.Screen name="Chats" component={ChatStack} />
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
}

Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\MatchesScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// MatchesScreen.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, StyleSheet, Alert, TouchableOpacity } from 'react-native';
import { Swipeable } from 'react-native-gesture-handler';
import { MaterialIcons } from '@expo/vector-icons';
import axiosInstance from '../api/axiosInstance'; // Use axiosInstance instead of axios
import AsyncStorage from '@react-native-async-storage/async-storage';

export default function MatchesScreen({ navigation }) {
  const [matches, setMatches] = useState([]);
  const [outgoingMatches, setOutgoingMatches] = useState([]);
  const [token, setToken] = useState('');

  useEffect(() => {
    const fetchMatches = async () => {
      const storedToken = await AsyncStorage.getItem('userToken');
      setToken(storedToken);

      try {
        const response = await axiosInstance.get('/matches'); // Base URL is handled by axiosInstance
        setMatches(response.data.matches);

        const outgoingResponse = await axiosInstance.get('/outgoingMatches');
        setOutgoingMatches(outgoingResponse.data.outgoingMatches);
      } catch (error) {
        console.error('Error fetching matches:', error);
      }
    };

    fetchMatches();
  }, []);

  const deleteOutgoingMatch = async (requestId) => {
    try {
      await axiosInstance.delete(`/matchRequests/${requestId}`);
      setOutgoingMatches(outgoingMatches.filter((match) => match.requestId !== requestId));
      Alert.alert('Match request canceled');
    } catch (error) {
      console.error('Error canceling match request:', error);
    }
  };

  const deleteMatch = async (matchId) => {
    try {
      await axiosInstance.delete(`/matches/${matchId}`);
      setMatches(matches.filter((match) => match.matchId !== matchId));
      Alert.alert('Match deleted');
    } catch (error) {
      console.error('Error deleting match:', error);
    }
  };

  const renderOutgoingItem = ({ item }) => (
    <Swipeable
      renderRightActions={(progress, dragX) => renderRightActionsForOutgoing(progress, dragX, item.requestId)}
    >
      <View style={styles.matchItem}>
        <Text style={styles.name}>{item.user.name}</Text>
        <Text style={styles.type}>
          Outgoing {item.type === 'romantic' ? 'Romantic' : 'Friend'} Request
        </Text>
      </View>
    </Swipeable>
  );

  const renderRightActionsForOutgoing = (progress, dragX, requestId) => {
    return (
      <TouchableOpacity
        style={styles.deleteButton}
        onPress={() => deleteOutgoingMatch(requestId)}
      >
        <MaterialIcons name="cancel" size={30} color="#fff" />
      </TouchableOpacity>
    );
  };

  const renderRightActions = (progress, dragX, matchId) => {
    return (
      <TouchableOpacity
        style={styles.deleteButton}
        onPress={() => deleteMatch(matchId)}
      >
        <MaterialIcons name="delete" size={30} color="#fff" />
      </TouchableOpacity>
    );
  };

  const openChat = async (match) => {
    try {
      const chat = {
        chatId: match.chatId,
        user: match.user,
      };
      navigation.navigate('Chat', { chat });
    } catch (error) {
      console.error('Error opening chat:', error);
    }
  };

  const renderItem = ({ item }) => (
    <Swipeable
      renderRightActions={(progress, dragX) => renderRightActions(progress, dragX, item.matchId)}
    >
      <TouchableOpacity onPress={() => openChat(item)}>
        <View style={styles.matchItem}>
          <Text style={styles.name}>{item.user.name}</Text>
          <Text style={styles.type}>
            Matched as {item.type === 'romantic' ? 'Romantic' : 'Friend'}
          </Text>
        </View>
      </TouchableOpacity>
    </Swipeable>
  );

  return (
    <View style={styles.container}>
      {matches.length > 0 && (
        <>
          <Text style={styles.sectionHeader}>Matches</Text>
          <FlatList
            data={matches}
            keyExtractor={(item) => item.matchId}
            renderItem={renderItem}
          />
        </>
      )}
      {outgoingMatches.length > 0 && (
        <>
          <Text style={styles.sectionHeader}>Outgoing Requests</Text>
          <FlatList
            data={outgoingMatches}
            keyExtractor={(item) => item.requestId}
            renderItem={renderOutgoingItem}
          />
        </>
      )}
      {matches.length === 0 && outgoingMatches.length === 0 && (
        <Text>No matches or outgoing requests yet.</Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
  },
  sectionHeader: {
    fontSize: 20,
    fontWeight: 'bold',
    marginVertical: 10,
  },
  matchItem: {
    padding: 15,
    borderBottomWidth: 1,
    backgroundColor: '#fff',
  },
  name: {
    fontSize: 18,
  },
  type: {
    fontSize: 14,
    color: 'gray',
  },
  deleteButton: {
    backgroundColor: 'red',
    justifyContent: 'center',
    alignItems: 'flex-end',
    padding: 20,
  },
});


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\ProfileScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// screens/ProfileScreen.js

import React, { useContext, useEffect, useState } from 'react';
import { View, Text, Button, StyleSheet, ActivityIndicator, Image, Alert, TextInput, ScrollView, TouchableOpacity } from 'react-native';
import { AuthContext } from '../context/AuthContext';
import axiosInstance from '../api/axiosInstance';
import * as ImagePicker from 'expo-image-picker';

const ProfileScreen = () => {
  const { logout } = useContext(AuthContext);
  const [profile, setProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [editing, setEditing] = useState(false);
  const [newProfile, setNewProfile] = useState({
    imageUrl: '',
    name: '',
    age: '',
    bio: '',
    tags: '',
    funThingsToDo: '',
    neighborhood: '',
  });

  useEffect(() => {
    fetchProfile();
  }, []);

  const fetchProfile = async () => {
    try {
      const response = await axiosInstance.get('/getUserProfile');
      setProfile(response.data);
      setNewProfile({
        imageUrl: response.data.imageUrl,
        name: response.data.name,
        age: response.data.age,
        bio: response.data.bio,
        tags: response.data.tags ? response.data.tags.join(', ') : '',
        funThingsToDo: response.data.funThingsToDo,
        neighborhood: response.data.neighborhood,
      });
      console.log('Fetched Profile:', response.data); // Debugging
    } catch (error) {
      console.error('Error fetching profile:', error.response?.data?.error || error.message);
      Alert.alert('Error', error.response?.data?.error || 'Failed to fetch profile.');
    } finally {
      setLoading(false);
    }
  };

  const handleImagePick = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });

    if (!result.cancelled) {
      setNewProfile({ ...newProfile, imageUrl: result.uri });
    }
  };

  const handleSaveProfile = async () => {
    try {
      const updatedProfile = {
        imageUrl: newProfile.imageUrl,
        name: newProfile.name,
        age: newProfile.age,
        bio: newProfile.bio,
        tags: newProfile.tags.split(',').map((tag) => tag.trim()),
        funThingsToDo: newProfile.funThingsToDo,
        neighborhood: newProfile.neighborhood,
      };

      const response = await axiosInstance.put('/updateUserProfile', updatedProfile);
      setProfile(response.data);
      setEditing(false);
      Alert.alert('Profile Updated', 'Your profile has been updated successfully.');
    } catch (error) {
      console.error('Error updating profile:', error.response?.data?.error || error.message);
      Alert.alert('Error', error.response?.data?.error || 'Failed to update profile.');
    }
  };

  if (loading) {
    return (
      <View style={styles.loaderContainer}>
        <ActivityIndicator size="large" color="#FF3B30" />
      </View>
    );
  }

  return (
    <ScrollView contentContainerStyle={styles.container}>
      {editing ? (
        <>
          <TouchableOpacity onPress={handleImagePick}>
            {newProfile.imageUrl ? (
              <Image source={{ uri: newProfile.imageUrl }} style={styles.avatar} />
            ) : (
              <View style={styles.avatarPlaceholder}>
                <Text style={styles.avatarText}>Pick Image</Text>
              </View>
            )}
          </TouchableOpacity>

          <TextInput
            style={styles.input}
            value={newProfile.name}
            onChangeText={(text) => setNewProfile({ ...newProfile, name: text })}
            placeholder="Name"
          />
          <TextInput
            style={styles.input}
            value={newProfile.age}
            onChangeText={(text) => setNewProfile({ ...newProfile, age: text })}
            placeholder="Age"
            keyboardType="numeric"
          />
          <TextInput
            style={styles.input}
            value={newProfile.bio}
            onChangeText={(text) => setNewProfile({ ...newProfile, bio: text })}
            placeholder="Bio"
            multiline
          />
          <TextInput
            style={styles.input}
            value={newProfile.tags}
            onChangeText={(text) => setNewProfile({ ...newProfile, tags: text })}
            placeholder="Profile Tags (comma separated)"
          />
          <TextInput
            style={styles.input}
            value={newProfile.funThingsToDo}
            onChangeText={(text) => setNewProfile({ ...newProfile, funThingsToDo: text })}
            placeholder="Fun Things To Do"
            multiline
          />
          <TextInput
            style={styles.input}
            value={newProfile.neighborhood}
            onChangeText={(text) => setNewProfile({ ...newProfile, neighborhood: text })}
            placeholder="Neighborhood in Charlotte"
          />

          <Button title="Save" onPress={handleSaveProfile} color="#FF3B30" />
          <Button title="Cancel" onPress={() => setEditing(false)} color="#666" />
        </>
      ) : (
        <>
          <TouchableOpacity onPress={handleImagePick}>
            {profile.imageUrl ? (
              <Image source={{ uri: profile.imageUrl }} style={styles.avatar} />
            ) : (
              <View style={styles.avatarPlaceholder}>
                <Text style={styles.avatarText}>{profile.name ? profile.name.charAt(0).toUpperCase() : 'U'}</Text>
              </View>
            )}
          </TouchableOpacity>
          <Text style={styles.name}>{profile.name}</Text>
          <Text style={styles.info}>Age: {profile.age}</Text>
          <Text style={styles.info}>Bio: {profile.bio}</Text>
          <Text style={styles.info}>Tags: {profile.tags ? profile.tags.join(', ') : 'N/A'}</Text>
          <Text style={styles.info}>Fun Things To Do: {profile.funThingsToDo || 'N/A'}</Text>
          <Text style={styles.info}>Neighborhood: {profile.neighborhood || 'N/A'}</Text>

          <View style={styles.buttonContainer}>
            <Button title="Edit Profile" onPress={() => setEditing(true)} color="#FF3B30" />
            <Button title="Logout" onPress={logout} color="#666" />
          </View>
        </>
      )}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    flexGrow: 1,
    padding: 20,
    backgroundColor: '#fff',
    alignItems: 'center',
  },
  avatar: {
    width: 150,
    height: 150,
    borderRadius: 75,
    marginBottom: 20,
  },
  avatarPlaceholder: {
    width: 150,
    height: 150,
    borderRadius: 75,
    backgroundColor: '#ccc',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  avatarText: {
    fontSize: 20,
    color: '#fff',
  },
  name: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#333',
  },
  info: {
    fontSize: 18,
    marginBottom: 5,
    color: '#666',
  },
  input: {
    width: '100%',
    padding: 10,
    marginVertical: 10,
    borderColor: '#ccc',
    borderWidth: 1,
    borderRadius: 10,
    fontSize: 16,
  },
  buttonContainer: {
    marginTop: 20,
    width: '100%',
  },
});

export default ProfileScreen;


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\SignUpScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// screens/SignUpScreen.js

import React, { useContext, useState } from 'react';
import { View, TextInput, Button, StyleSheet, TouchableOpacity, Text, Alert, ActivityIndicator } from 'react-native';
import { AuthContext } from '../context/AuthContext';

const SignUpScreen = ({ navigation }) => {
  const { signUp, loading } = useContext(AuthContext);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const [age, setAge] = useState('');
  const [bio, setBio] = useState('');

  const handleSignUp = () => {
    if (email.trim() === '' || password.trim() === '') {
      Alert.alert('Error', 'Please enter both email and password.');
      return;
    }
    signUp(email, password, age, bio);
  };

  if (loading) {
    return (
      <View style={styles.loaderContainer}>
        <ActivityIndicator size="large" color="#FF3B30" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>CltMeet2 Sign Up</Text>
      <TextInput
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        style={styles.input}
        autoCapitalize="none"
        keyboardType="email-address"
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        style={styles.input}
        secureTextEntry
      />
      <TextInput
        placeholder="Age (optional)"
        value={age}
        onChangeText={setAge}
        style={styles.input}
        keyboardType="numeric"
      />
      <TextInput
        placeholder="Bio (optional)"
        value={bio}
        onChangeText={setBio}
        style={[styles.input, styles.textArea]}
        multiline
        numberOfLines={4}
      />
      <Button title="Sign Up" onPress={handleSignUp} />
      <TouchableOpacity onPress={() => navigation.goBack()}>
        <Text style={styles.link}>Already have an account? Login</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#fff',
    justifyContent: 'center',
  },
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    marginBottom: 30,
    textAlign: 'center',
    fontWeight: 'bold',
    color: '#FF3B30',
  },
  input: {
    height: 50,
    borderColor: '#ccc',
    borderWidth: 1,
    marginBottom: 15,
    paddingHorizontal: 15,
    borderRadius: 8,
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  link: {
    color: '#1E90FF',
    marginTop: 15,
    textAlign: 'center',
    fontSize: 16,
  },
});

export default SignUpScreen;


Path: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens\SwiperScreen.js
Directory: c:\Users\Manav\Documents\Programming\Projects\CltMeet2\screens
Contents:
// SwiperScreen.js

import React, { useState, useEffect, useRef, useContext } from 'react';
import { View, Text, Image, StyleSheet, TouchableOpacity, Alert, ActivityIndicator } from 'react-native';
import Swiper from 'react-native-deck-swiper';
import { Entypo } from '@expo/vector-icons';
import axiosInstance from '../api/axiosInstance'; // Use axiosInstance
import { AuthContext } from '../context/AuthContext'; // Import AuthContext

export default function SwiperScreen() {
    
    
  const [profiles, setProfiles] = useState([]);
  const [lastVisible, setLastVisible] = useState(null);
  const [loadingProfiles, setLoadingProfiles] = useState(true);
  const swiperRef = useRef(null);
  const { userToken, logout } = useContext(AuthContext); // Access userToken from AuthContext

  useEffect(() => {
    console.log('SwiperScreen useEffect triggered');
    const fetchProfiles = async () => {
      if (!userToken) {
        console.log('No userToken afirevailable, cannot fetch profiles');
        Alert.alert('Authentication Error', 'Please log in to view profiles.', [
          { text: 'OK', onPress: () => {} },
        ]);
        return;
      }

      try {
        console.log('Fetching profiles...');
        const response = await axiosInstance.get('/profiles', {
          params: {
            pageSize: 10,
            lastVisible: lastVisible,
          },
        });

        console.log('API Response:', response.data);

        const { profiles: newProfiles, lastVisible: newLast } = response.data;

        if (!newProfiles || newProfiles.length === 0) {
          console.warn('No profiles received from API');
          Alert.alert('No Profiles', 'No more profiles available.');
          setLoadingProfiles(false);
          return;
        }

        setProfiles((prev) => [...prev, ...newProfiles]);
        setLastVisible(newLast);
        console.log(`Fetched ${newProfiles.length} profiles`);
      } catch (error) {
        console.error('Error fetching profiles:', error);
        Alert.alert('Error', 'Failed to load profiles.');
      } finally {
        setLoadingProfiles(false);
      }
    };

    fetchProfiles();
  }, [userToken, lastVisible]);

  const handleChoice = async (profile, type) => {
    console.log(`Handling choice: ${type} for profile: ${profile.name} (UID: ${profile.uid})`);
    if (!userToken) {
      console.log('No userToken available, cannot send choice');
      Alert.alert('Authentication Error', 'Please log in to perform actions.');
      return;
    }

    try {
      const response = await axiosInstance.post('/markSeen', {
        seenUserId: profile.uid,
        action: type,
      });

      console.log('Choice Response:', response.data);

      if (response.data.chatId) {
        Alert.alert(`You matched with ${profile.name}!`, 'Navigate to chat?', [
          {
            text: 'Cancel',
            style: 'cancel',
          },
          {
            text: 'Go to Chat',
            onPress: () => {
              navigation.navigate('Chat', { chat: { chatId: response.data.chatId, name: profile.name } });
            },
          },
        ]);
      } else if (response.data.message) {
        Alert.alert('Success', response.data.message);
      } else {
        Alert.alert('Success', 'Action completed successfully.');
      }

      console.log(`Swiping right on profile: ${profile.name}`);
      swiperRef.current.swipeRight();
    } catch (error) {
      console.error('Error handling choice:', error);
      Alert.alert('Error', 'Failed to perform the action.');
    }
  };

  const onSwipedLeft = async (cardIndex) => {
    const passedProfile = profiles[cardIndex];
    console.log(`Swiped left on profile: ${passedProfile.name} (UID: ${passedProfile.uid})`);

    if (!userToken) {
      console.log('No userToken available, cannot mark as passed');
      Alert.alert('Authentication Error', 'Please log in to perform actions.');
      return;
    }

    try {
      await axiosInstance.post('/markSeen', {
        seenUserId: passedProfile.uid,
        action: 'pass',
      });

      console.log(`Marked profile as passed: ${passedProfile.name}`);
      Alert.alert('Passed', `You passed on ${passedProfile.name}.`);
    } catch (error) {
      console.error('Error marking profile as passed:', error);
      Alert.alert('Error', 'Failed to mark profile as passed.');
    }
  };

  const loadMoreProfiles = async () => {
    if (lastVisible) {
      console.log('Loading more profiles...');
      setLastVisible(lastVisible); // Trigger useEffect to fetch more profiles
    }
  };

  // Render loading indicator if profiles are still loading
  if (loadingProfiles) {
    console.log('Loading profiles...');
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007aff" />
        <Text>Loading profiles...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {profiles.length > 0 ? (
        <>
          <Swiper
            ref={swiperRef}
            cards={profiles}
            renderCard={(card) => {
              console.log('Rendering card:', card);
              if (!card) {
                return (
                  <View style={styles.card}>
                    <Text>No more profiles</Text>
                  </View>
                );
              }
              return (
                <View style={styles.card}>
                  <Image source={{ uri: card.imageUrl }} style={styles.image} />
                  <Text style={styles.name}>
                    {card.name}, {card.age}
                  </Text>
                  <View style={styles.choiceContainer}>
                    <TouchableOpacity
                      style={[styles.choiceButton, { backgroundColor: '#4ecdc4' }]}
                      onPress={() => handleChoice(card, 'friend')}
                    >
                      <Text style={styles.choiceText}>Friend</Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.choiceButton, { backgroundColor: '#ff6b6b' }]}
                      onPress={() => handleChoice(card, 'romantic')}
                    >
                      <Text style={styles.choiceText}>Romantic</Text>
                    </TouchableOpacity>
                  </View>
                </View>
              );
            }}
            onSwipedLeft={onSwipedLeft}
            onSwipedAll={loadMoreProfiles}
            cardIndex={0}
            backgroundColor={'#f0f0f0'}
            stackSize={3}
            disableRightSwipe // Disable manual right swipe to enforce using buttons
            infinite={false}
            animateCardOpacity
          />
          <View style={styles.controlContainer}>
            <TouchableOpacity
              onPress={() => {
                console.log('Manual swipe left triggered');
                swiperRef.current.swipeLeft();
              }}
              style={styles.controlButton}
            >
              <Entypo name="cross" size={50} color="red" />
            </TouchableOpacity>
          </View>
        </>
      ) : (
        <View style={styles.noProfilesContainer}>
          <Text>No profiles available.</Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  card: {
    flex: 0.75,
    borderRadius: 10,
    shadowRadius: 25,
    shadowColor: '#000',
    shadowOpacity: 0.08,
    shadowOffset: { width: 0, height: 0 },
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 10,
  },
  image: {
    width: '95%',
    height: '75%',
    borderRadius: 10,
    marginBottom: 10,
  },
  name: {
    fontSize: 24,
    marginTop: 10,
    fontWeight: '600',
  },
  choiceContainer: {
    flexDirection: 'row',
    marginTop: 20,
  },
  choiceButton: {
    flex: 1,
    padding: 15,
    marginHorizontal: 10,
    borderRadius: 5,
    alignItems: 'center',
  },
  choiceText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  controlContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 20,
  },
  controlButton: {
    padding: 10,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noProfilesContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});


